import matplotlib as mpl
from matplotlib import rc
import matplotlib.pyplot as plt
import numpy as np
import sys

mpl.rcParams.update({'font.size': 22})

# returns an array for which each index corresponds to a map qualty
# and is an array of 0/1 integers where 1 means an accurate alignment
# was found and 0 means the opposite. Takes a bowtie generated
# sam alignment file and a mason --verbose generates fq file.
def check_alignment(samFile, fqFile):

    # skip header
    line = samFile.readline()
    while line[0] == '@':
        last_pos = samFile.tell()
        line = samFile.readline()
        
    samFile.seek(last_pos)

    # read in alignment positions from samFile
    alignments = {}
    reads = 0
    num_aligned = 0
    for line in samFile:
        data = line.strip().split()        
        flags = int(data[1])
        if flags != 4:
            num_aligned += 1
            name = data[0]
            alignment = int(data[3])
            mapq = int(data[4])
            alignments[name] = (alignment, mapq)            
        reads += 1
    samFile.close()

    # read in correct alignments from mason generated fq File
    ref_origins = {}
    count = 0
    for line in fqFile:
        if count % 4 == 0:
            data = line.strip().split()
            name = data[0][1:]
            ref = int(data[4][11:])
            ref_origins[name] = ref
        count += 1
    fqFile.close()

    # make array of how many alignements were correct or incorrect at each map quality
    total_alignments = [[] for i in range(43)]
    for key in alignments:
        if abs(alignments[key][0] - ref_origins[key]) <= 3:
            if alignments[key][1] >= len(total_alignments):
                total_alignments.extend([[] for i in range(alignments[key][1] - len(total_alignments) + 1)])
            total_alignments[alignments[key][1]].append(1)
        else:
            if alignments[key][1] >= len(total_alignments):
                total_alignments.extend([[] for i in range(alignments[key][1] - len(total_alignments) + 1)])
            total_alignments[alignments[key][1]].append(0)

    return total_alignments


# Given two arrays of the form generated by the function check_alignment
# above and an integer which is the number of alignments to compare, this
# function returns an array for which the each index is how many alignments
# runA was accurate more than runB for alignments at map qualities higher
# than and equal to the one at this index. If x is greater than the total
# number of alignments in either A or B, the minimum number of alignments
# between these two is used
def compare_alignments(A, B, x):
    A.reverse()
    B.reverse()
    Asize = 0
    for m in A:
        Asize += len(m)
    Bsize = 0
    for n in B:
        Bsize += len(n)
    total = min(Asize, Bsize)        
    if x > total:
        x = total

    diff_total = 0
    diff = 0
    aouti = 0
    bouti = 0
    aini = 0
    bini = 0
    plot_array = [0 for _ in range(total)]
    for i in range(total):
        while aini >= len(A[aouti]):
            aouti += 1
            aini = 0
        while bini >= len(B[bouti]):
            bouti += 1
            bini = 0
        if A[aouti][aini] == 0:
            if i < x:
                diff -= 1
                diff_total -= 1
            else:
                diff_total -= 1
        if B[bouti][bini] == 0:
            if i < x:
                diff += 1
                diff_total += 1
            else:
                diff_total += 1
        plot_array[i] = diff_total
        aini+=1
        bini+=1
    

    return diff, plot_array, (x - 1)

        
# takes in 4 command like arguments: 1 = mason generated fq file,
# 2 = sam file for run A, 3 = sam file for run B, 4 = num alignments
# to check. Plots the difference in accuracy between runs.
def main():
        fqFile = open(sys.argv[1], "r")
        samFile = open(sys.argv[2], "r")
        alignmentsA =  check_alignment(samFile, fqFile)

        samFile2 = open(sys.argv[3], "r")
        fqFile = open(sys.argv[1], "r")
        alignmentsB =  check_alignment(samFile2, fqFile)       

        x = int(sys.argv[4])
        diff, plot_array, x = compare_alignments(alignmentsA, alignmentsB, x)

        better = ""
        if diff >= 0:
            better = "run A"
        else:
            better = "run B"

        max_diff = max(abs(min(plot_array)), max(plot_array))
            
        print('\nThe better aligned run was {}\nIt was better by {} alignments when looking at the top {} alignemnts.'.format(better, abs(diff), x + 1))
        plt.plot([i for i in range(len(plot_array))], plot_array)
        ax = plt.gca()
        ax.set_xlim(left=0)
        ax.spines['bottom'].set_position(('data',0))
        plt.scatter([x], plot_array[x], 50, color='red')
        plt.annotate('$X = $' + str(x) + '$, Y = $' + str(plot_array[x]),
             xy=(x, plot_array[x]), xycoords='data',
             xytext=(+100, +60), textcoords='offset points', fontsize=32,
             arrowprops=dict(arrowstyle="->", connectionstyle="arc3,rad=.2"))
        ax.set_title('Y > 0 means run A is doing better\n Y < 0 means run B is doing better', fontsize=60)
        ax.set_xlabel('Number of Alignments, sorted in descending order by mapping quality', fontsize=40, labelpad=510)
        ax.set_ylabel('Difference in number of misalignments (runB - runA)', fontsize=40)
        plt.ylim(-(max_diff + 5), max_diff + 5)
        plt.show()
                
main()
            
    
