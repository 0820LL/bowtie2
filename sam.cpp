/*
 * Copyright 2011, Ben Langmead <blangmea@jhsph.edu>
 *
 * This file is part of Bowtie 2.
 *
 * Bowtie 2 is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Bowtie 2 is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Bowtie 2.  If not, see <http://www.gnu.org/licenses/>.
 */

#include <string>
#include <sys/time.h>
#include "sam.h"
#include "filebuf.h"

using namespace std;

/**
 * Print a reference name in a way that doesn't violate SAM's character
 * constraints. \*|[!-()+-<>-~][!-~]* (i.e. [33, 63], [65, 126])
 */
void SamConfig::printRefName(
	OutFileBuf& o,
	const std::string& name) const
{
	size_t namelen = name.length();
	for(size_t i = 0; i < namelen; i++) {
		if(isspace(name[i])) {
			return;
		}
		o.write(name[i]);
	}
}

/**
 * Print a reference name given a reference index.
 */
void SamConfig::printRefNameFromIndex(OutFileBuf& o, size_t i) const {
	printRefName(o, refnames_[i]);
}

/**
 * Print SAM header to given output buffer.
 */
void SamConfig::printHeader(
	OutFileBuf& o,
	const string& rgid,
	const string& rgs,
	bool printHd,
	bool printSq,
	bool printPg) const
{
	if(printHd) printHdLine(o, "1.0");
	if(printSq) printSqLines(o);
	if(!rgid.empty()) {
		o.writeChars("@RG");
		o.writeString(rgid);
		o.writeString(rgs);
		o.write('\n');
	}
	if(printPg) printPgLine(o);
}

/**
 * Print the @HD header line to the given OutFileBuf.
 */
void SamConfig::printHdLine(OutFileBuf& o, const char *samver) const {
	o.writeChars("@HD\tVN:");
	o.writeChars(samver);
	o.writeChars("\tSO:unsorted\n");
}

/**
 * Print the @SQ header lines to the given OutFileBuf.
 */
void SamConfig::printSqLines(OutFileBuf& o) const {
	char buf[1024];
	for(size_t i = 0; i < refnames_.size(); i++) {
		o.writeChars("@SQ\tSN:");
		printRefName(o, refnames_[i]);
		o.writeChars("\tLN:");
		itoa10<size_t>(reflens_[i], buf);
		o.writeChars(buf);
		o.write('\n');
	}
}

/**
 * Print the @PG header line to the given OutFileBuf.
 */
void SamConfig::printPgLine(OutFileBuf& o) const {
	o.writeChars("@PG\tID:");
	o.writeString(pg_id_);
	o.writeChars("\tPN:");
	o.writeString(pg_pn_);
	o.writeChars("\tVN:");
	o.writeString(pg_vn_);
	o.write('\n');
}

#define WRITE_SEP() { \
	if(!first) o.write('\t'); \
	first = false; \
}

/**
 * Print the optional flags to the given OutFileBuf.
 */
void SamConfig::printAlignedOptFlags(
	OutFileBuf& o,          // output buffer
	bool first,             // first opt flag printed is first overall?
	const Read& rd,         // the read
	const AlnRes& res,      // individual alignment result
	const AlnFlags& flags,  // alignment flags
	const AlnSetSumm& summ, // summary of alignments for this read
	const SeedAlSumm& ssm,  // seed alignment summary
	const char *mapqInp)    // inputs to MAPQ calculation
	const
{
	char buf[1024];
	if(print_as_) {
		// AS:i: Alignment score generated by aligner
		itoa10<TAlScore>(res.score().score(), buf);
		WRITE_SEP();
		o.writeChars("AS:i:");
		o.writeChars(buf);
	}
	if(print_xs_) {
		// XS:i: Suboptimal alignment score
		AlnScore sc = summ.secbestMate(rd.mate < 2);
		if(sc.valid()) {
			itoa10<TAlScore>(sc.score(), buf);
			WRITE_SEP();
			o.writeChars("XS:i:");
			o.writeChars(buf);
		}
	}
	if(print_xn_) {
		// XN:i: Number of ambiguous bases in the referenece
		itoa10<size_t>(res.refNs(), buf);
		WRITE_SEP();
		o.writeChars("XN:i:");
		o.writeChars(buf);
	}
	if(print_x0_) {
		// X0:i: Number of best hits
	}
	if(print_x1_) {
		// X1:i: Number of sub-optimal best hits
	}
	size_t num_mm = 0;
	size_t num_go = 0;
	size_t num_gx = 0;
	for(size_t i = 0; i < res.ned().size(); i++) {
		if(res.ned()[i].isMismatch()) {
			num_mm++;
		} else if(res.ned()[i].isReadGap()) {
			num_go++;
			num_gx++;
			while(i < res.ned().size()-1 &&
				  res.ned()[i+1].pos == res.ned()[i].pos &&
				  res.ned()[i+1].isReadGap())
			{
				i++;
				num_gx++;
			}
		} else if(res.ned()[i].isRefGap()) {
			num_go++;
			num_gx++;
			while(i < res.ned().size()-1 &&
				  res.ned()[i+1].pos == res.ned()[i].pos+1 &&
				  res.ned()[i+1].isRefGap())
			{
				i++;
				num_gx++;
			}
		}
	}
	if(print_xm_) {
		// XM:i: Number of mismatches in the alignment
		itoa10<size_t>(num_mm, buf);
		WRITE_SEP();
		o.writeChars("XM:i:");
		o.writeChars(buf);
	}
	if(print_xo_) {
		// XO:i: Number of gap opens
		itoa10<size_t>(num_go, buf);
		WRITE_SEP();
		o.writeChars("XO:i:");
		o.writeChars(buf);
	}
	if(print_xg_) {
		// XG:i: Number of gap extensions (incl. opens)
		itoa10<size_t>(num_gx, buf);
		WRITE_SEP();
		o.writeChars("XG:i:");
		o.writeChars(buf);
	}
	if(print_nm_) {
		// NM:i: Edit dist. to the ref, Ns count, clipping doesn't
		itoa10<size_t>(res.ned().size(), buf);
		WRITE_SEP();
		o.writeChars("NM:i:");
		o.writeChars(buf);
	}
	if(print_md_) {
		// MD:Z: String for mms. [0-9]+(([A-Z]|\^[A-Z]+)[0-9]+)*2
		WRITE_SEP();
		o.writeChars("MD:Z:");
		res.printMD(
			const_cast<EList<char>&>(tmpmdop_),    // MD operations
			const_cast<EList<char>&>(tmpmdch_),    // MD chars
			const_cast<EList<size_t>&>(tmpmdrun_), // MD run lengths
			&o,         // output buffer
			NULL);      // no char buffer
	}
	if(print_ys_ && summ.paired()) {
		// AS:i: Alignment score generated by aligner
		assert(res.oscore().valid());
		itoa10<TAlScore>(res.oscore().score(), buf);
		WRITE_SEP();
		o.writeChars("YS:i:");
		o.writeChars(buf);
	}
	if(print_yt_) {
		// YT:Z: String representing alignment type
		WRITE_SEP();
		flags.printYT(o);
	}
	if(print_yp_ && flags.partOfPair() && flags.canMax()) {
		// YP:i: Read was repetitive when aligned paired?
		WRITE_SEP();
		flags.printYP(o);
	}
	if(print_ym_ && flags.canMax() && (flags.isMixedMode() || !flags.partOfPair())) {
		// YM:i: Read was repetitive when aligned unpaired?
		WRITE_SEP();
		flags.printYM(o);
	}
	if(print_yf_ && flags.filtered()) {
		// YF:i: Read was filtered?
		first = flags.printYF(o, first) && first;
	}
	if(print_yi_) {
		// Print MAPQ calibration info
		if(mapqInp[0] != '\0') {
			// YI:i: Suboptimal alignment score
			WRITE_SEP();
			o.writeChars("YI:Z:");
			o.writeChars(mapqInp);
		}
	}
	if(!rgs_.empty()) {
		WRITE_SEP();
		o.writeString(rgs_);
	}
	if(print_seed_fields_) {
		// Z0: # non-zero poss
		WRITE_SEP();
		o.writeChars("Z0:i:");
		itoa10<TAlScore>(ssm.nonzTot, buf);
		o.writeChars(buf);
		// Z1: # non-zero poss fw
		WRITE_SEP();
		o.writeChars("Z1:i:");
		itoa10<TAlScore>(ssm.nonzFw, buf);
		o.writeChars(buf);
		// Z2: # non-zero poss rc
		WRITE_SEP();
		o.writeChars("Z2:i:");
		itoa10<TAlScore>(ssm.nonzRc, buf);
		o.writeChars(buf);
		// Z3: # ranges
		WRITE_SEP();
		o.writeChars("Z3:i:");
		itoa10<TAlScore>(ssm.nrangeTot, buf);
		o.writeChars(buf);
		// Z4: # ranges fw
		WRITE_SEP();
		o.writeChars("Z4:i:");
		itoa10<TAlScore>(ssm.nrangeFw, buf);
		o.writeChars(buf);
		// Z5: # ranges rc
		WRITE_SEP();
		o.writeChars("Z5:i:");
		itoa10<TAlScore>(ssm.nrangeRc, buf);
		o.writeChars(buf);
		// Z6: # elements
		WRITE_SEP();
		o.writeChars("Z6:i:");
		itoa10<TAlScore>(ssm.neltTot, buf);
		o.writeChars(buf);
		// Z7: # elements fw
		WRITE_SEP();
		o.writeChars("Z7:i:");
		itoa10<TAlScore>(ssm.neltFw, buf);
		o.writeChars(buf);
		// Z8: # elements rc
		WRITE_SEP();
		o.writeChars("Z8:i:");
		itoa10<TAlScore>(ssm.neltRc, buf);
		o.writeChars(buf);
		// Z9: min # ranges per nonz fw
		WRITE_SEP();
		o.writeChars("Z9:i:");
		itoa10<TAlScore>(ssm.minNonzRangeFw, buf);
		o.writeChars(buf);
		// ZZ: min # ranges per nonz rc
		WRITE_SEP();
		o.writeChars("ZZ:i:");
		itoa10<TAlScore>(ssm.minNonzRangeRc, buf);
		o.writeChars(buf);
		// ZY: max # ranges per nonz fw
		WRITE_SEP();
		o.writeChars("ZY:i:");
		itoa10<TAlScore>(ssm.maxNonzRangeFw, buf);
		o.writeChars(buf);
		// ZX: max # ranges per nonz rc
		WRITE_SEP();
		o.writeChars("ZX:i:");
		itoa10<TAlScore>(ssm.maxNonzRangeRc, buf);
		o.writeChars(buf);
		// ZW: min # elts per nonz fw
		WRITE_SEP();
		o.writeChars("ZW:i:");
		itoa10<TAlScore>(ssm.minNonzEltFw, buf);
		o.writeChars(buf);
		// ZV: min # elts per nonz rc
		WRITE_SEP();
		o.writeChars("ZV:i:");
		itoa10<TAlScore>(ssm.minNonzEltRc, buf);
		o.writeChars(buf);
		// ZU: max # elts per nonz fw
		WRITE_SEP();
		o.writeChars("ZU:i:");
		itoa10<TAlScore>(ssm.maxNonzEltFw, buf);
		o.writeChars(buf);
		// ZT: max # elts per nonz rc
		WRITE_SEP();
		o.writeChars("ZT:i:");
		itoa10<TAlScore>(ssm.maxNonzEltRc, buf);
		o.writeChars(buf);
	}
	if(print_xt_) {
		// XT:i: Timing
		WRITE_SEP();
		struct timeval  tv_end;
		struct timezone tz_end;
		gettimeofday(&tv_end, &tz_end);
		size_t total_usecs =
			(tv_end.tv_sec  - rd.tv_beg.tv_sec) * 1000000 +
			(tv_end.tv_usec - rd.tv_beg.tv_usec);
		itoa10<size_t>(total_usecs, buf);
		o.writeChars("XT:i:");
		o.writeChars(buf);
	}
	if(print_xd_) {
		// XD:i: Extend DPs
		WRITE_SEP();
		itoa10<uint64_t>(rd.nExDps, buf);
		o.writeChars("XD:i:");
		o.writeChars(buf);
		// Xd:i: Mate DPs
		WRITE_SEP();
		itoa10<uint64_t>(rd.nMateDps, buf);
		o.writeChars("Xd:i:");
		o.writeChars(buf);
	}
	if(print_xu_) {
		// XU:i: Extend ungapped tries
		WRITE_SEP();
		itoa10<uint64_t>(rd.nExUngaps, buf);
		o.writeChars("XU:i:");
		o.writeChars(buf);
		// Xu:i: Mate ungapped tries
		WRITE_SEP();
		itoa10<uint64_t>(rd.nMateUngaps, buf);
		o.writeChars("Xu:i:");
		o.writeChars(buf);
	}
	if(print_ye_) {
		// YE:i: Streak of failed DPs at end
		WRITE_SEP();
		itoa10<uint64_t>(rd.nDpFail, buf);
		o.writeChars("YE:i:");
		o.writeChars(buf);
		// Ye:i: Streak of failed ungaps at end
		WRITE_SEP();
		itoa10<uint64_t>(rd.nUgFail, buf);
		o.writeChars("Ye:i:");
		o.writeChars(buf);
	}
	if(print_yl_) {
		// YL:i: Longest streak of failed DPs
		WRITE_SEP();
		itoa10<uint64_t>(rd.nDpFailStreak, buf);
		o.writeChars("YL:i:");
		o.writeChars(buf);
		// Yl:i: Longest streak of failed ungaps
		WRITE_SEP();
		itoa10<uint64_t>(rd.nUgFailStreak, buf);
		o.writeChars("Yl:i:");
		o.writeChars(buf);
	}
	if(print_yu_) {
		// YU:i: Index of last succesful DP
		WRITE_SEP();
		itoa10<uint64_t>(rd.nDpLastSucc, buf);
		o.writeChars("YU:i:");
		o.writeChars(buf);
		// Yu:i: Index of last succesful DP
		WRITE_SEP();
		itoa10<uint64_t>(rd.nUgLastSucc, buf);
		o.writeChars("Yu:i:");
		o.writeChars(buf);
	}
	if(print_yr_) {
		// YR:i: Redundant seed hits
		WRITE_SEP();
		itoa10<uint64_t>(rd.nRedundants, buf);
		o.writeChars("YR:i:");
		o.writeChars(buf);
	}
	if(print_zi_) {
		// ZI:i: Seed extend loop iterations
		WRITE_SEP();
		itoa10<uint64_t>(rd.nExIters, buf);
		o.writeChars("ZI:i:");
		o.writeChars(buf);
	}
}

/**
 * Print the optional flags to the given OutFileBuf.
 */
void SamConfig::printEmptyOptFlags(
	OutFileBuf& o,          // output buffer
	bool first,             // first opt flag printed is first overall?
	const Read& rd,         // read
	const AlnFlags& flags,  // alignment flags
	const AlnSetSumm& summ, // summary of alignments for this read
	const SeedAlSumm& ssm)  // seed alignment summary
	const
{
	char buf[1024];
	if(print_yt_) {
		// YT:Z: String representing alignment type
		WRITE_SEP();
		flags.printYT(o);
	}
	if(print_yp_ && flags.partOfPair() && flags.canMax()) {
		// YP:i: Read was repetitive when aligned paired?
		WRITE_SEP();
		flags.printYP(o);
	}
	if(print_ym_ && flags.canMax() && (flags.isMixedMode() || !flags.partOfPair())) {
		// YM:i: Read was repetitive when aligned unpaired?
		WRITE_SEP();
		flags.printYM(o);
	}
	if(print_yf_ && flags.filtered()) {
		// YM:i: Read was repetitive when aligned unpaired?
		first = flags.printYF(o, first) && first;
	}
	if(!rgs_.empty()) {
		WRITE_SEP();
		o.writeString(rgs_);
	}
	if(print_seed_fields_) {
		// Z0: # non-zero poss
		WRITE_SEP();
		o.writeChars("Z0:i:");
		itoa10<TAlScore>(ssm.nonzTot, buf);
		o.writeChars(buf);
		// Z1: # non-zero poss fw
		WRITE_SEP();
		o.writeChars("Z1:i:");
		itoa10<TAlScore>(ssm.nonzFw, buf);
		o.writeChars(buf);
		// Z2: # non-zero poss rc
		WRITE_SEP();
		o.writeChars("Z2:i:");
		itoa10<TAlScore>(ssm.nonzRc, buf);
		o.writeChars(buf);
		// Z3: # ranges
		WRITE_SEP();
		o.writeChars("Z3:i:");
		itoa10<TAlScore>(ssm.nrangeTot, buf);
		o.writeChars(buf);
		// Z4: # ranges fw
		WRITE_SEP();
		o.writeChars("Z4:i:");
		itoa10<TAlScore>(ssm.nrangeFw, buf);
		o.writeChars(buf);
		// Z5: # ranges rc
		WRITE_SEP();
		o.writeChars("Z5:i:");
		itoa10<TAlScore>(ssm.nrangeRc, buf);
		o.writeChars(buf);
		// Z6: # elements
		WRITE_SEP();
		o.writeChars("Z6:i:");
		itoa10<TAlScore>(ssm.neltTot, buf);
		o.writeChars(buf);
		// Z7: # elements fw
		WRITE_SEP();
		o.writeChars("Z7:i:");
		itoa10<TAlScore>(ssm.neltFw, buf);
		o.writeChars(buf);
		// Z8: # elements rc
		WRITE_SEP();
		o.writeChars("Z8:i:");
		itoa10<TAlScore>(ssm.neltRc, buf);
		o.writeChars(buf);
		// Z9: min # ranges per nonz fw
		WRITE_SEP();
		o.writeChars("Z9:i:");
		itoa10<TAlScore>(ssm.minNonzRangeFw, buf);
		o.writeChars(buf);
		// ZZ: min # ranges per nonz rc
		WRITE_SEP();
		o.writeChars("ZZ:i:");
		itoa10<TAlScore>(ssm.minNonzRangeRc, buf);
		o.writeChars(buf);
		// ZY: max # ranges per nonz fw
		WRITE_SEP();
		o.writeChars("ZY:i:");
		itoa10<TAlScore>(ssm.maxNonzRangeFw, buf);
		o.writeChars(buf);
		// ZX: max # ranges per nonz rc
		WRITE_SEP();
		o.writeChars("ZX:i:");
		itoa10<TAlScore>(ssm.maxNonzRangeRc, buf);
		o.writeChars(buf);
		// ZW: min # elts per nonz fw
		WRITE_SEP();
		o.writeChars("ZW:i:");
		itoa10<TAlScore>(ssm.minNonzEltFw, buf);
		o.writeChars(buf);
		// ZV: min # elts per nonz rc
		WRITE_SEP();
		o.writeChars("ZV:i:");
		itoa10<TAlScore>(ssm.minNonzEltRc, buf);
		o.writeChars(buf);
		// ZU: max # elts per nonz fw
		WRITE_SEP();
		o.writeChars("ZU:i:");
		itoa10<TAlScore>(ssm.maxNonzEltFw, buf);
		o.writeChars(buf);
		// ZT: max # elts per nonz rc
		WRITE_SEP();
		o.writeChars("ZT:i:");
		itoa10<TAlScore>(ssm.maxNonzEltRc, buf);
		o.writeChars(buf);
	}
	if(print_xt_) {
		// XT:i: Timing
		WRITE_SEP();
		struct timeval  tv_end;
		struct timezone tz_end;
		gettimeofday(&tv_end, &tz_end);
		size_t total_usecs =
			(tv_end.tv_sec  - rd.tv_beg.tv_sec) * 1000000 +
			(tv_end.tv_usec - rd.tv_beg.tv_usec);
		itoa10<size_t>(total_usecs, buf);
		o.writeChars("XT:i:");
		o.writeChars(buf);
	}
	if(print_xd_) {
		// XD:i: Extend DPs
		WRITE_SEP();
		itoa10<uint64_t>(rd.nExDps, buf);
		o.writeChars("XD:i:");
		o.writeChars(buf);
		// Xd:i: Mate DPs
		WRITE_SEP();
		itoa10<uint64_t>(rd.nMateDps, buf);
		o.writeChars("Xd:i:");
		o.writeChars(buf);
	}
	if(print_xu_) {
		// XU:i: Extend ungapped tries
		WRITE_SEP();
		itoa10<uint64_t>(rd.nExUngaps, buf);
		o.writeChars("XU:i:");
		o.writeChars(buf);
		// Xu:i: Mate ungapped tries
		WRITE_SEP();
		itoa10<uint64_t>(rd.nMateUngaps, buf);
		o.writeChars("Xu:i:");
		o.writeChars(buf);
	}
	if(print_ye_) {
		// YE:i: Streak of failed DPs at end
		WRITE_SEP();
		itoa10<uint64_t>(rd.nDpFail, buf);
		o.writeChars("YE:i:");
		o.writeChars(buf);
		// Ye:i: Streak of failed ungaps at end
		WRITE_SEP();
		itoa10<uint64_t>(rd.nUgFail, buf);
		o.writeChars("Ye:i:");
		o.writeChars(buf);
	}
	if(print_yl_) {
		// YL:i: Longest streak of failed DPs
		WRITE_SEP();
		itoa10<uint64_t>(rd.nDpFailStreak, buf);
		o.writeChars("YL:i:");
		o.writeChars(buf);
		// Yl:i: Longest streak of failed ungaps
		WRITE_SEP();
		itoa10<uint64_t>(rd.nUgFailStreak, buf);
		o.writeChars("Yl:i:");
		o.writeChars(buf);
	}
	if(print_yu_) {
		// YU:i: Index of last succesful DP
		WRITE_SEP();
		itoa10<uint64_t>(rd.nDpLastSucc, buf);
		o.writeChars("YU:i:");
		o.writeChars(buf);
		// Yu:i: Index of last succesful DP
		WRITE_SEP();
		itoa10<uint64_t>(rd.nUgLastSucc, buf);
		o.writeChars("Yu:i:");
		o.writeChars(buf);
	}
	if(print_yr_) {
		// YR:i: Redundant seed hits
		WRITE_SEP();
		itoa10<uint64_t>(rd.nRedundants, buf);
		o.writeChars("YR:i:");
		o.writeChars(buf);
	}
	if(print_zi_) {
		// ZI:i: Seed extend loop iterations
		WRITE_SEP();
		itoa10<uint64_t>(rd.nExIters, buf);
		o.writeChars("ZI:i:");
		o.writeChars(buf);
	}
}
