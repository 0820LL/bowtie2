#!/usr/bin/perl -w

#
# mermaid:
#
# A simple, Perl-based gapped aligner for testing and for small-genome
# projects.
#

use strict;
use warnings;
use Heap::Priority;
use Carp;
use FindBin qw($Bin);
use lib $Bin;
use Edit;
use PartialAln;
use Reporter;
use SearchScheme;
use Getopt::Long;
Getopt::Long::Configure ("no_ignore_case", "pass_through");

my $usage_msg = q!
Usage: 
  mermaid [options]* <ref> {-1 <m1> -2 <m2> | --12 <r> | <s>} [<hit>]

  <fasta> Comma-separated list of FASTA files or raw sequences to be used as
          reference sequences.
  <m1>    Comma-separated list of files containing upstream mates (or the
          sequences themselves, if -c is set) paired with mates in <m2>
  <m2>    Comma-separated list of files containing downstream mates (or the
          sequences themselves if -c is set) paired with mates in <m1>
  <r>     Comma-separated list of files containing Crossbow-style reads.  Can be
          a mixture of paired and unpaired.  Specify "-" for stdin.
  <s>     Comma-separated list of files containing unpaired reads, or the
          sequences themselves, if -c is set.  Specify "-" for stdin.
  <hit>   File to write hits to (default: stdout)
Input:
  -q                 query input files are FASTQ .fq/.fastq (default)
  -f                 query input files are (multi-)FASTA .fa/.mfa
  -r                 query input files are raw one-sequence-per-line
  -c                 query sequences given on cmd line (as <mates>, <singles>)
  -C                 reads and index are in colorspace
  -Q/--quals <file>  QV file(s) corresponding to CSFASTA inputs; use with -f -C
  --Q1/--Q2 <file>   same as -Q, but for mate files 1 and 2 respectively
  -s/--skip <int>    skip the first <int> reads/pairs in the input
  -u/--qupto <int>   stop after first <int> reads/pairs (excl. skipped reads)
  -5/--trim5 <int>   trim <int> bases from 5' (left) end of reads
  -3/--trim3 <int>   trim <int> bases from 3' (right) end of reads
  --phred33-quals    input quals are Phred+33 (default)
  --phred64-quals    input quals are Phred+64 (same as --solexa1.3-quals)
  --solexa-quals     input quals are from GA Pipeline ver. < 1.3
  --solexa1.3-quals  input quals are from GA Pipeline ver. >= 1.3
  --integer-quals    qualities are given as space-separated integers (not ASCII)
Alignment:
  -v <int>           report end-to-end hits w/ <=v mismatches; ignore qualities
    or
  -n/--seedmms <int> max mismatches in seed (can be 0-3, default: -n 2)
  -e/--maqerr <int>  max sum of mismatch quals across alignment for -n (def: 70)
  -l/--seedlen <int> seed length for -n (default: 28)
  --nomaqround       disable Maq-like quality rounding for -n (nearest 10 <= 30)
  -I/--minins <int>  minimum insert size for paired-end alignment (default: 0)
  -X/--maxins <int>  maximum insert size for paired-end alignment (default: 250)
  --fr/--rf/--ff     -1, -2 mates align fw/rev, rev/fw, fw/fw (default: --fr)
  --nofw/--norc      do not align to forward/reverse-complement reference strand
  --maxbts <int>     max # backtracks for -n 2/3 (default: 125, 800 for --best)
  --pairtries <int>  max # attempts to find mate for anchor hit (default: 100)
  -y/--tryhard       try hard to find valid alignments, at the expense of speed
  --chunkmbs <int>   max megabytes of RAM for best-first search frames (def: 64)
Reporting:
  -k <int>           report up to <int> good alignments per read (default: 1)
  -a/--all           report all alignments per read (much slower than low -k)
  -m <int>           suppress all alignments if > <int> exist (def: no limit)
  -M <int>           like -m, but reports 1 random hit (MAPQ=0); requires --best
  --best             hits guaranteed best stratum; ties broken by quality
  --strata           hits in sub-optimal strata aren't reported (requires --best)
Output:
  -t/--time          print wall-clock time taken by search phases
  -B/--offbase <int> leftmost ref offset = <int> in bowtie output (default: 0)
  --quiet            print nothing but the alignments
  --refout           write alignments to files refXXXXX.map, 1 map per reference
  --refidx           refer to ref. seqs by 0-based index rather than name
  --al <fname>       write aligned reads/pairs to file(s) <fname>
  --un <fname>       write unaligned reads/pairs to file(s) <fname>
  --max <fname>      write reads/pairs over -m limit to file(s) <fname>
  --suppress <cols>  suppresses given columns (comma-delim'ed) in default output
  --fullref          write entire ref name (default: only up to 1st space)
Colorspace:
  --snpphred <int>   Phred penalty for SNP when decoding colorspace (def: 30)
     or
  --snpfrac <dec>    approx. fraction of SNP bases (e.g. 0.001); sets --snpphred
  --col-cseq         print aligned colorspace seqs as colors, not decoded bases
  --col-cqual        print original colorspace quals, not decoded quals
  --col-keepends     keep nucleotides at extreme ends of decoded alignment
SAM:
  -S/--sam           write hits in SAM format
  --mapq <int>       default mapping quality (MAPQ) to print for SAM alignments
  --sam-nohead       supppress header lines (starting with @) for SAM output
  --sam-nosq         supppress @SQ header lines for SAM output
  --sam-RG <text>    add <text> (usually "lab=value") to @RG line of SAM header
Performance:
  -o/--offrate <int> override offrate of index; must be >= index's offrate
  -p/--threads <int> number of alignment threads to launch (default: 1)
  --mm               use memory-mapped I/O for index; many 'bowtie's can share
  --shmem            use shared mem for index; many 'bowtie's can share
Other:
  --seed <int>       seed for random number generator
  --verbose          verbose output (for debugging)
  --version          print version information and quit
  -h/--help          print this usage message
!;

my @optnames = (
	"q", # FASTQ input
	"f", # FASTA input
	"r", # Raw input
	"c", # Input specified on command line
	"C", # Input is colorspace
	"Q|quals=s",
	"Q1=s",
	"Q2=s",
	"s|skip=i",
	"u|qupto=i",
	"5|trim5=i",
	"3|trim3=i",
	"phred33-quals",
	"phred64-quals",
	"solexa-quals",
	#"solexa1.3-quals",
	# TODO: solexa1.3-quals doesn't work w/ GetOpts
	"solexa13-quals",
	"integer-quals",
	"v=i",
	"n=i",
	"e=i",
	"l=i",
	"nomaqround",
	"I|minins=i",
	"X|maxins=i",
	"fr",
	"rf",
	"ff",
	"nofw",
	"norc",
	"maxbts=i",
	"pairtries=i",
	"y|tryhard",
	"chunkmbs=i",
	"k=i",
	"a|all",
	"m=i",
	"M=i",
	"best",
	"strata",
	"t|time",
	"B",
	"offbase",
	"quiet",
	"refout",
	"refidx",
	"al=s",
	"un=s",
	"max=s",
	"suppress=i",
	"fullref",
	"snpphred=i",
	"snpfrac=f",
	"col-cseq",
	"col-cqual",
	"col-keepends",
	"S|sam",
	"mapq=i",
	"sam-nohead",
	"sam-nosq",
	"sam-RG=s",
	"o|offrate=i",
	"mm",
	"shmem",
	"seed=i",
	"verbose",
	"version",
	"h|help"
);

my %opts = ();
GetOptions (\%opts, @optnames) || die "One or more bad options (see above)\n";

if($opts{verbose}) {
	for my $o (@optnames) {
		$o =~ s/[=:|].*//;
		print STDERR "$o = ".(!defined($opts{$o}) ? "undefined" : $opts{$o})."\n";
	}
}

sub stderr() {
	my $fh;
	open($fh, ">/dev/stderr") || die;
	return $fh;
}

sub stdout() {
	my $fh;
	open($fh, ">/dev/stdout") || die;
	return $fh;
}

##
# Print usage message to given filehandle.
#
sub usage($) {
	my $fh = shift;
	print {$fh} $usage_msg;
	exit 0;
}

if($opts{h}) { usage(stderr()) }

scalar(@ARGV) == 2 || scalar(@ARGV) == 3 ||
	croak ("Expected options then 2 or 3 arguments, but saw ".scalar(@ARGV)." arguments:\n@ARGV\n");

my $reflistStr = shift @ARGV;
my $readlistStr = shift @ARGV;
my $outputStr = (scalar(@ARGV) > 0 ? shift @ARGV : "/dev/stdout");

my @reflist = split(/,/, $reflistStr);
my @readlist = split(/,/, $readlistStr);

##
# Start an alignment job given all of the command-line options
# specified by the user.
#
sub align {
	# References
	my $refs = Reference::newFromList(\@reflist);
	defined($refs) || croak("No refs\n");
	# Reads
	my $reads = undef;
	if($opts{q}) {
		$reads = Read::fromFastqs(\@readlist, $opts{C});
	} elsif($opts{f}) {
		$reads = Read::fromFastas(\@readlist, $opts{C});
	} elsif($opts{c}) {
		$reads = Read::fromStrings(\@readlist, $opts{C});
	}
	defined($reads) || croak("No reads\n");
	print STDERR "Loaded ".scalar(@$reads)." reads\n" if $opts{verbose};
	# Search scheme and cost model
	my $abstractScheme = undef;
	my $costModel = undef;
	if($opts{v}) {
		$abstractScheme = SearchScheme::soap_like($opts{v});
		$costModel = CostModel::allOnes(); # doesn't matter
	} elsif($opts{P}) {
		($abstractScheme, $costModel) = SearchScheme::parsePolicy($opts{P});
	} else {
		$abstractScheme = SearchScheme::maqLike(
			$opts{n}, $opts{l}, $opts{e}, 1, !$opts{nofw}, !$opts{norc});
		$costModel = CostModel::maqLike();
	}
	# Output formatter
	my $outfh;
	open($outfh, ">$outputStr")
		|| croak("Could not open output filehandle \"$outputStr\"\n");
	my $formatter = sub { Formatter::bowtie($outfh, @_) };
	# Reporter
	my $reporter = new Reporter($refs, $opts{k}, $opts{m}, $formatter, $opts{"flush-ival"});
	# Substring set function
	my $strset = Reference::perlHashStrset($refs);
	# Log function
	my $logfunc = $opts{verbose} ? sub { print STDERR "$_[0]\n" } : sub { };
	my $idx = 0;
	for my $read (@$reads) {
		$idx++;
		print STDERR "Aligning read $idx\n" if $opts{verbose};
		# Search heap
		my $heap = new Heap::Priority();
		# Results buffer
		my $results = new ResultAlns($refs);
		# Concrete scheme
		my $scheme = $abstractScheme->instantiate($read);
		
		# Instantiate scheme
		PartialAln::addSearchSchemeToHeap($heap, $scheme, $read);
		# Run the aligner
		my $advances = 0;
		while(PartialAln::popAndAdvance($costModel, $heap, $strset, $results, $logfunc)) {
			$advances++;
		}
		# Report results
		$reporter->report($results);
	}
	close($outfh);
}

align();

