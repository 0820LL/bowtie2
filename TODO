Bowtie 2 TODO list:
- In general, the bottleneck is DP.  Is there a FM Index/DP division of labor
  that lets us do fewer DPs overall without sacrificing sensitivity or
  accuracy?
- Soft/hard trimming taken into account when setting up paired-end problems?
- Support non-N IUPAC characters
- A better way of pursuing dynamic programming problems; one that allows use of
  the latest Rognes approach.  E.g. buffer up potential DP problems then solve
  them in chunks of 8 at a time.  Then the resulting max scores tell us which
  we should resolve first.
- Add faster DP filter to run first
- Binary search to find reference records instead of linear scan
- Align seeds in random order and investigate each seed immediately after
  aligning it
- Let opposite mate finding be driven by seed hits, not spread across a huge
  window
- Spliced alignment
- Unroll inner loop for local alignment?  Try to take pressure off loads that
  are dominating the profile?
- Faster ungapped mode for when either (a) the user asks for it, or (b) the
  score threshold is such that there can be no gap opens
- More wrapper script features
- Why so much profile on vh = _mm_adds_epi16(vh, pvScore[1]);?
- Restore --overhang flag

Aggressive seeding:
- Idea:
  + Extend seeds as far as possible before trying any DPs
  + Have various cutoffs; i.e. to extend from length 15 to 16 requires having
	at least some score, etc
  + Facility for noticing as soon as one seed is "subsumed" by another
- Pros:
  + Might be able to eliminate vast majority of large ranges
  + Would be more reasonable to put an aggressive cap on large ranges
  + Perhaps splicedness can be guessed at here?
- Cons:
  + Complicated
  + Unknown effect

Low priority:
- Output locking can be economical.  SAM records can be written to strings,
  then flushed while locked.

How to compare tools:

- Speed/sensitivity
- MAPQ failures
- A aligned / B failed to align
- Alignment length? (average? MAPQ-like comparison?)

