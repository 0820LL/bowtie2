/*
 * sam.cpp
 */

#include "sam.h"
#include "filebuf.h"
#include "aligner_result.h"

using namespace std;

/**
 * [!-?A-~]{1,255}
 */
void SamConfig::printReadName(
	OutFileBuf& o,
	const std::string& name) const
{
	for(size_t i = 0; i < name.length(); i++) {
		if(isspace(name[i])) {
			return;
		}
		o.write(name[i]);
	}
}

/**
 * Print a reference name in a way that doesn't violate SAM's character
 * constraints. \*|[!-()+-<>-~][!-~]*
 */
void SamConfig::printRefName(
	OutFileBuf& o,
	const std::string& name) const
{
	for(size_t i = 0; i < name.length(); i++) {
		if(isspace(name[i])) {
			return;
		}
		o.write(name[i]);
	}
}

/**
 * Print a reference name given a reference index.
 */
void SamConfig::printRefNameFromIndex(OutFileBuf& o, size_t i) const {
	printRefName(o, refnames_[i]);
}

/**
 * Print SAM header to given output buffer.
 */
void SamConfig::printHeader(
	OutFileBuf& o,
	bool printSq,
	bool printPg) const
{
	if(printSq) printSqLines(o);
	if(printPg) printPgLine(o);
}

/**
 * Print the @SQ header lines to the given OutFileBuf.
 */
void SamConfig::printSqLines(OutFileBuf& o) const {
	char buf[1024];
	for(size_t i = 0; i < refnames_.size(); i++) {
		o.writeChars("@SQ\tSN:");
		o.writeString(refnames_[i]);
		o.writeChars("\tLN:");
		itoa10<size_t>(reflens_[i], buf);
		o.writeChars(buf);
		o.write('\n');
	}
}

/**
 * Print the @PG header line to the given OutFileBuf.
 */
void SamConfig::printPgLine(OutFileBuf& o) const {
	o.writeChars("@PG\tID:");
	o.writeString(pg_id_);
	o.writeChars("\tPN:");
	o.writeString(pg_pn_);
	o.writeChars("\tVN:");
	o.writeString(pg_vn_);
	o.write('\n');
}

/**
 * Print the optional flags to the given OutFileBuf.
 */
void SamConfig::printAlignedOptFlags(
	OutFileBuf& o,          // output buffer
	bool first,             // first opt flag printed is first overall?
	bool exEnds,            // exclude ends of sequence?
	const AlnRes& res,      // individual alignment result
	const AlnFlags& flags,  // alignment flags
	const AlnSetSumm& summ) // summary of alignments for this read
	const
{
	char buf[1024];
	if(print_as_) {
		// AS:i: Alignment score generated by aligner
		itoa10<TAlScore>(res.score().score(), buf);
		if(!first) o.write('\t');
		first = false;
		o.writeChars("AS:i:");
		o.writeChars(buf);
	}
	if(print_xs_) {
		// XS:i: Suboptimal alignment score
		AlnScore sc = summ.secbest();
		itoa10<TAlScore>(sc.valid() ? sc.score() : 0, buf);
		if(!first) o.write('\t');
		first = false;
		o.writeChars("XS:i:");
		o.writeChars(buf);
	}
	if(print_xn_) {
		// XN:i: Number of ambiguous bases in the referenece
		AlnScore sc = summ.secbest();
		itoa10<size_t>(res.refNs(), buf);
		if(!first) o.write('\t');
		first = false;
		o.writeChars("XN:i:");
		o.writeChars(buf);
	}
	if(print_x0_) {
		// X0:i: Number of best hits
	}
	if(print_x1_) {
		// X1:i: Number of sub-optimal best hits
	}
	size_t num_mm = 0;
	size_t num_go = 0;
	size_t num_gx = 0;
	for(size_t i = 0; i < res.ned().size(); i++) {
		if(res.ned()[i].isMismatch()) {
			num_mm++;
		} else if(res.ned()[i].isReadGap()) {
			num_go++;
			num_gx++;
			while(i < res.ned().size()-1 &&
				  res.ned()[i+1].pos == res.ned()[i].pos &&
				  res.ned()[i+1].isReadGap())
			{
				i++;
				num_gx++;
			}
		} else if(res.ned()[i].isRefGap()) {
			num_go++;
			num_gx++;
			while(i < res.ned().size()-1 &&
				  res.ned()[i+1].pos == res.ned()[i].pos+1 &&
				  res.ned()[i+1].isRefGap())
			{
				i++;
				num_gx++;
			}
		}
	}
	if(print_xm_) {
		// XM:i: Number of mismatches in the alignment
		itoa10<size_t>(num_mm, buf);
		if(!first) o.write('\t');
		first = false;
		o.writeChars("XM:i:");
		o.writeChars(buf);
	}
	if(print_xo_) {
		// XO:i: Number of gap opens
		itoa10<size_t>(num_go, buf);
		if(!first) o.write('\t');
		first = false;
		o.writeChars("XO:i:");
		o.writeChars(buf);
	}
	if(print_xg_) {
		// XG:i: Number of gap extensions (incl. opens)
		itoa10<size_t>(num_gx, buf);
		if(!first) o.write('\t');
		first = false;
		o.writeChars("XG:i:");
		o.writeChars(buf);
	}
	if(print_nm_) {
		// NM:i: Edit dist. to the ref, Ns count, clipping doesn't
		itoa10<size_t>(res.ned().size(), buf);
		if(!first) o.write('\t');
		first = false;
		o.writeChars("NM:i:");
		o.writeChars(buf);
	}
	if(print_md_) {
		// MD:Z: String for mms. [0-9]+(([A-Z]|\^[A-Z]+)[0-9]+)*2
		if(!first) o.write('\t');
		first = false;
		o.writeChars("MD:Z:");
		res.printMD(
			false,      // print colors
			exEnds,     // exclude nucleotide ends
			const_cast<EList<char>&>(tmpmdop_),    // MD operations
			const_cast<EList<char>&>(tmpmdch_),    // MD chars
			const_cast<EList<size_t>&>(tmpmdrun_), // MD run lengths
			&o,         // output buffer
			NULL);      // no char buffer
	}
	if(print_ym_) {
		// YM:i: Read was repetitive when aligned unpaired?
		if(!first) o.write('\t');
		first = false;
		flags.printYM(o);
	}
	if(print_yp_) {
		// YP:i: Read was repetitive when aligned paired?
		if(!first) o.write('\t');
		first = false;
		flags.printYP(o);
	}
	if(print_yt_) {
		// YT:Z: String representing alignment type
		if(!first) o.write('\t');
		first = false;
		flags.printYT(o);
	}
}

/**
 * Print the optional flags to the given OutFileBuf.
 */
void SamConfig::printEmptyOptFlags(
	OutFileBuf& o,          // output buffer
	bool first,             // first opt flag printed is first overall?
	const AlnFlags& flags,  // alignment flags
	const AlnSetSumm& summ) // summary of alignments for this read
	const
{
	// Print nothing (like BWA & BWA-SW)
}
